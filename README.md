# Исследование хештаблиц

В данной работе бы ла написана хештаблица методом списков и исследованы два ее ключевых атрибута:
хешфункции и функция поиска.

## Часть 1. Исследование хеш-функций
Хеш функция имеет сигнатуру `uint64_t func(const char *str)` и считает хеш только C-like строк (с терминирующим нулем).
В качестве хеш функций были рассмотрены:

| Имя           | Алгоритм                                                 | Стандартное отклонение | Время работы, мс |
|---------------|----------------------------------------------------------|:----------------------:|------------------|
| Константа     | `hash(*str) = 22801337`                                  |          866           | ??               |
| Длина строки  | `hash(*str) = strlen(str)`                               |          223           | ??               |
| Первый символ | `hash(*str) = str[0]`                                    |          197           | ??               |
| Сумма         | `hash(*str) = sum(str[i])`                               |          23.3          | ??               |
| ROR-хеш       | `hash(*str) = {hash=0; for (ch in str) {ror(hash)+ch}}`  |          8.1           | 7.89 ± 0.08      |
| ROL-хеш       | `hash(*str) = {hash=0; for (ch in str) {rol(hash)+ch}}`  |          5.1           | 7.90 ± 0.04      |
| GNU хеш       | `hash(*str) = {hash=5381; for (ch in str) {33*hash+ch}}` |          3.6           | 8.390 ± 0.010    |
| CRC32         | `hash(*str) = crc32(str)`                                |          3.6           | 64.73 ± 0.17     |
| CRC32 (SSE)   | `hash(*str) = crc32(str)`                                |          3.6           | 0.942  ± 0.025   |

Для каждой функции построим графики длин цепочек aka графики распределения и посчитаем дисперсию и время их работы.
За время работы будем считать подсчет хеша от всех слов в словаре 10 раз (`common.h::HASH_REPEAT_NUM`), не вставляя элементы в действительности

### Анализ распределений

Как и ожидалось, константный хеш имеет самое плохое распределение из возможных, превращая хештаблицу
в связный список:
![const_hash.png](images%2Fconst_hash.png)

Уже чуть лучше себя показывают хеш-функции длины / первого символа, однако их распределение тоже
далеко от идеального в силу ограничений естественного языка.
![strlen_hash.png](images%2Fstrlen_hash.png)
![first_char_hash.png](images%2Ffirst_char_hash.png)

Так, например, различных букв всего 26, а значит диапазон принимаемых хешфункцией значений очень ограничен.
Длина строки не лучше: слова длиннее 20 букв в природе очень редко, а значит диапазон значений strlen тоже мал.

Более хорошо это видно на приближенный графиках:
![strlen_hash_detailed.png](images%2Fstrlen_hash_detailed.png)
![first_char_hash_detailed.png](images%2Ffirst_char_hash_detailed.png)

Прочие хеши показывают себя гораздо лучше, однако та же сумма в силу вышеописанных свойств естественного языка тоже имеет
ограниченный набор значений:
![sum_hash.png](images%2Fsum_hash.png)

rol/ror и прочие хеши не имеют таких недостатков и потому показывают гораздо лучшие распределения:
![rol_hash.png](images%2Frol_hash.png)
![ror_hash.png](images%2Fror_hash.png)
![gnu_hash.png](images%2Fgnu_hash.png)
![crc32_hash.png](images%2Fcrc32_hash.png)

С хеш-функциями rol/ror связана интересная особенность компилятора: хоть код и был написан на C без
использования ассемблера, компилятор превратил
```cpp
uint64_t rol(uint64_t byte) {
    return ((byte << 1)) | (byte >> 63);
}
```
в
```asm
rol(unsigned long):
    mov     rax, rdi
    rol     rax
    ret
```
как видно в Godbolt:
![godbolt-rol.png](images%2Fscreenshots%2Fgodbolt-rol.png)

Однако в хешфункциях нас интересует не только их распределение, но и скорость работы, так как это очень сильно влияет
на скорость работы хештаблицы в целом (это будет показано далее). Построим график отклонения от времени работы для всех
функций, имеющих адекватное время работы.

![time_disturb.png](images%2Ftime_disturb.png)

Как видно, без учета векторной реализации `crc32` самым оптимальным хешем является хеш `gnu`, однако
для более честного измерения ассемблерных оптимизаций далее мы будем использовать `crc32` из-за наличия
аппаратного ускорения.


## Часть 2. Ускорение поиска

### Методика измерений
Тесты проводились на AMD Ryzen 7 4800H с версией компилятора GCC v12.2.1. Для чистоты измерений во время замеров на ноутбуке не было запущено никаких других приложений,
планировщик CPU был выставлен в perfomance (процессор зафиксирован на максимальной частоте) и программе был выдан максимальный приоритет.

Все версии программы собирались с флагами `-O2 -mavx2 -DNDEBUG`.

### v1. Примитивная версия
Для начала измерим примитивную версию хештаблицы, где узлами списка являются структуры
```c++
struct double_node_t {
    char key[32];
    char *value;
    double_node_t *next;
};
```

Поиск всех ключей в данной таблице занимает `13.7 ± 0.2 ms`.

### v2. Оптимизируем память
Прежде чем перейти к суровым оптимизациям, заметим, что мы не оптимально используем кеш. Проверить это можно с помощью Cachegring:
